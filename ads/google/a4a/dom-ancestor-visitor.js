/**
 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {computedStyle} from '../../../src/style';
import {devAssert} from '../../../src/log';

/** @typedef {function(*): undefined} */
let ResolverTypeDef;

/** @typedef {
 *    function(!Element, !Object<string, string>, !ResolverTypeDef): *
 *  }
 */
let CallbackTypeDef;

/** @typedef {{
 *    callback: !CallbackTypeDef,
 *    resolver: !ResolverTypeDef,
 *    maxDepth: number,
 *    active: boolean,
 *    result: *
 *  }}
 */
let VisitorTaskTypeDef;

class VisitorTask {
  /**
   * @param {!CallbackTypeDef} callback
   * @param {number} maxAncestorsToVisit
   */
  constructor(callback, maxAncestorsToVisit) {
    /** @private @const {!CallbackTypeDef} */
    this.callback_ = callback;

    /** @private @const {!ResolverTypeDef} */
    this.resolver_ = (result) => {
      this.result_ = result;
      this.complete_ = true;
    };

    /** @private @const {number} */
    this.maxAncestorsToVisit_ = maxAncestorsToVisit;

    /** @private {*} */
    this.result_ = null;

    /** @private {boolean} */
    this.complete_ = false;
  }

  /**
   * @param {?Element} element
   * @param {!Object<string, string>} style
   */
  callback(element, style) {
    this.callback_(element, style, this.resolver_);
  }

  /** @return {boolean} */
  isComplete() {
    return this.complete_;
  }

  /** @return {number} */
  getMaxAncestorsToVisit() {
    return this.maxAncestorsToVisit_;
  }

  /** @return {*} */
  getResult() {
    return this.result_;
  }
}

/**
 * Utility class that will visit every ancestor of a given element (up to a
 * given maximum depth), and call the provided callback functions on each
 * element, passing in the element and its computed styles as arguments to the
 * callbacks. Callbacks are also passed a resolver function which may be called
 * from within the callback to stop the callback from being called on further
 * elements.
 *
 * This is useful when it is required to gather CSS information on an element's
 * ancestors, and it is desirable to do so in a single pass.
 */
export class DomAncestorVisitor {

  /** @param {!Window=} win */
  constructor(win = window) {
    /**
     * List of tasks to execute during each visit.
     * @private @const {!Object<string, !VisitorTask>}
     */
    this.visitorTasks_ = {};

    /**
     * List of completed tasks.
     * @private @const {!Object<string, !VisitorTask>}
     */
    this.completedVisitorTasks_ = {};

    /** @private @const {!Window} */
    this.win_ = win;
  }

  /**
   * @param {string} taskName
   * @param {!CallbackTypeDef} callback
   * @param {number=} maxAncestorsToVisit The limit of how many ancestors this
   *   task should be executed on. Must be positive.
   * @return {!DomAncestorVisitor}
   */
  addVisitorTask(taskName, callback, maxAncestorsToVisit = 100) {
    devAssert(maxAncestorsToVisit > 0,
        'maxAncestorsToVisit must be a positive value.');
    this.visitorTasks_[taskName] =
        new VisitorTask(callback, maxAncestorsToVisit);
    return this;
  }

  /**
   * Returns the result generated by the callback with the given name.
   * @param {string} taskName
   * @return {*}
   */
  getResultFor(taskName) {
    return this.completedVisitorTasks_[taskName].getResult();
  }

  /**
   * Returns the result generated by the callback with the given name. If the
   * result is null or undefined, the default value will be returned.
   * @param {string} taskName
   * @param {*} defaultVal
   * @return {*}
   */
  getResultForOrDefault(taskName, defaultVal) {
    const result = this.getResultFor(taskName);
    return result == undefined ? defaultVal : result;
  }

  /**
   * @param {?Element}
   * @return {!DomAncestorVisitor}
   */
  visitAncestorsStartingFrom(element) {
    let el = element;
    let ancestorsVisited = 0;
    let taskNames = Object.keys(this.visitorTasks_);
    while (el && taskNames.length) {
      ancestorsVisited++;
      const style = computedStyle(this.win_, el);
      taskNames.forEach(taskName => {
        const task = this.visitorTasks_[taskName];
        try {
          task.callback(el, style);
        } catch (e) {
          // TODO just log the error
        }
        if (task.isComplete() ||
            ancestorsVisited >= task.getMaxAncestorsToVisit()) {
          this.completedVisitorTasks_[taskName] = task;
          delete this.visitorTasks_[taskName];
        }
      });
      el = el.parentElement;
      // Some tasks might have been removed in the previous iteration, so we
      // need to reset this value.
      taskNames = Object.keys(this.visitorTasks_);
    }
    return this;
  }
}
