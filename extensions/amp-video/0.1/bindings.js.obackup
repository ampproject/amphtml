/**
  * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS-IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
import {CSS} from '../../../build/amp-video-0.1.css';
import {EMPTY_METADATA} from '../../../src/mediasession-helper';
import {ElementProps} from '../../../src/element-props';
import {MediaPoolEvents} from '../../../src/service/media-pool-impl';
import {MediaType} from '../../../src/service/media-pool-impl';
import {Services} from '../../../src/services';
import {VideoEvents} from '../../../src/video-interface';
import {
  VideoMarkup,
  isCachedByCdn,
  assertHttpsSrc,
  isHls,
  hasAnyCachedSources,
  getPreloadSrc,
} from './markup';
import {VisibilityState} from '../../../src/visibility-state';
import {applyFillContent} from '../../../src/layout';
import {assertHttpsUrl} from '../../../src/url';
import {
  childElementByTag,
  childElementsByTag,
  closestByTag,
  createElementWithAttributes,
  elementByTag,
  fullscreenEnter,
  fullscreenExit,
  insertAfterOrAtStart,
  isFullscreenElement,
  removeElement,
} from '../../../src/dom';
import {dev, user} from '../../../src/log';
import {dict} from '../../../src/utils/object';
import {forwardEvent} from '../../../src/event-helper';
import {getData} from '../../../src/event-helper';
import {getMode} from '../../../src/mode';
import {installVideoManagerForDoc,} from '../../../src/service/video-manager-impl';
import {isExperimentOn} from '../../../src/experiments';
import {isLayoutSizeDefined} from '../../../src/layout';
import {listen} from '../../../src/event-helper';
import {once} from '../../../src/utils/function';
import {preconnectForElement} from '../../../src/preconnect';
import {setImportantStyles} from '../../../src/style';
import {toArray} from '../../../src/types';


/** @abstract */
export class VideoBinding {
  /**
   * @return {!Promise}
   * @abstract
   */
  loadPromise() {}

  registerOnVideoManager() {}

  /** @package */
  preloadCallback() {}

  /** @package */
  layoutCallback() {}

  /** @package */
  preload() {}

  /** @package */
  play() {}

  /** @package */
  pause(opt_rewindToBeginning) {}

  /** @package */
  mute() {}

  /** @package */
  unmute() {}

  /** @package */
  rewindToBeginning() {}
}


export class VideoElementBinding extends VideoBinding {
  constructor(element) {
    super();
    this.element_ = element;
    this.video_ = null;
  }

  isVideoSupported() {
    return !!this.video_.play;
  }

  isSupported(win, sourceOrAmpElement) {
    return true;
  }

  loadPromise() {
    return loadPromise(this.video_);
  }

  /** @override */
  maybeBuildVideo(unusedWin) {
    const {ownerDocument} = this.element_;
    const video = ownerDocument.createElement('video');
    this.video_ = video;
    return video;
  }

  /** @param {!AmpVideo} ampVideo */
  registerOnVideoManager(ampVideo) {
    const element = this.element_;
    installVideoManagerForDoc(element);
    Services.videoManagerForDoc(element).register(ampVideo);
  }

  /**
   * @param {string} eventType
   * @param {!EventListener} callback
   */
  listen(eventType, callback) {
    listen(this.assertVideo_(), eventType, callback);
  }

  /**
   * @return {!Element}
   * @private
   */
  assertVideo_() {
    return /** @type {!HTMLMediaElement} */ (dev().assertElement(this.video_));
  }

  play() {
    this.assertVideo_().play();
  }

  pause(rewindToBeginning = false) {
    this.assertVideo_().pause();
    if (!rewindToBeginning) {
      return;
    }
    this.rewindToBeginning();
  }

  mute() {
    this.assertVideo_().mute()
  }

  unmute() {
    this.assertVideo_().unmute();
  }

  rewindToBeginning() {
    this.assertVideo_().currentTime = 0;
  }

  isMuted() {
    return this.assertVideo_().muted;
  }
}


export class MediaPoolBinding extends VideoBinding {
  constructor(element, propagation) {
    super();
    this.propagation_ = propagation;
    this.element_ = element;
    this.pool_ = null;

    // TODO(alanorozco): Move this to mediapool interface
    this.element = element;
  }

  isVideoSupported() {
    return true;
  }

  isSupported(win, sourceOrAmpVideo) {
    // TODO: win to consturctor, experiment flag constant
    return !isHls(sourceOrAmpVideo) ||
        !isExperimentOn(win, 'disable-amp-story-hls');
  }

  loadPromise() {
    return this.pool_.preload(this);
  }

  maybeBuildVideo(win) {
    const element = this.element_;
    const {ownerDocument} = element;
    const pool = Services.mediaPoolFor(win).getFor(element);

    this.pool_ = pool;

    pool.register(this)

    const fallback = createElementWithAttributes(ownerDocument,
      'i-amphtml-placeholder',
      dict({'class': 'amp-hidden'}));

    Services.vsyncFor(win).mutate(() => {
      applyFillContent(fallback, true);
      element.appendChild(fallback);
    });

    this.installEventHandlers_();

    return null;
  }

  preloadCallback() {
    this.pool_.preload(this);
  }

  installEventHandlers_() {
    this.listen(VideoEvents.PLAYING, () =>
        this.element_.toggleFallback(false));

    this.listen(VideoEvents.PLAYING, MediaPoolEvents.SWAPPED_OUT,
        () => this.toggleFallback(true));
  }

  layoutCallback() {
    const fallback = this.element_.getFallback();
    const src = this.element_.getAttribute('poster');

    loadImage(src).then(() => this.mutateElement(() => {
      setImportantStyles(fallback, {'background-image': `url(${src})`});
    }));

    this.element.toggleFallback(true);
  }

  /**
   * @param {string} eventType
   * @param {!EventListener} callback
   */
  listen(eventType, callback) {
    this.pool_.listen(this, eventType, callback);
  }

  // MediaPoolConsumer implementation

  /** @override */
  getMediaType() {
    return MediaType.VIDEO;
  }

  /** @override */
  getMediaElementProps() {
    return this.propagation_.getElementProps();
  }

  /** @override */
  getMediaElementContent() {
    const {ownerDocument} = this.element_;
    const fragment = ownerDocument.createDocumentFragment();
    const propagation = this.propagation_;

    // TODO(alanorozco): propagation.observe
    propagation.setState(/* VISIBLE */ 2);

    return propagation.createDocumentFragment();
  }

  isMuted() {
    return this.pool_.isMuted(this);
  }

  play() {
    return this.pool_.play(this);
  }

  pause(rewindToBeginning = false) {
    return this.pool_.pause(this, rewindToBeginning);
  }

  mute() {
    return this.pool_.mute(this)
  }

  unmute() {
    return this.pool_.unmute(this);
  }

  rewindToBeginning() {
    return this.pool_.rewindToBeginning(this);
  }
}
