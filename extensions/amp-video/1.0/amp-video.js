/**
 * Copyright 2020 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {CSS} from '../../../build/amp-video-1.0.css';
import {VideoBaseElement} from './base-element';
import {isExperimentOn} from '../../../src/experiments';
import {pureUserAssert as userAssert} from '../../../src/core/assert';
import {toArray} from '../../../src/types';
import {
  childElementsByTag,
} from '../../../src/dom';
import {Services} from '../../../src/services';

/** @const {string} */
const TAG = 'amp-video';

export class AmpVideo extends VideoBaseElement {
  /**
   * AMP Cache may selectively cache certain video sources (based on various
   * heuristics such as video type, extensions, etc...).
   * When AMP Cache does so, it rewrites the `src` for `amp-video` and
   * `source` children that are cached and adds a `amp-orig-src` attribute
   * pointing to the original source.
   *
   * There are two separate runtime concerns that we handle here:
   *
   * 1) Handling 404s
   * Eventhough AMP Cache rewrites the `src` to point to the CDN, the actual
   * video may not be ready in the cache yet, in those cases the CDN will
   * return a 404.
   * AMP Cache also rewrites Urls for all sources and returns 404 for types
   * that are not supported to be cached.
   *
   * Runtime handles this situation by appending an additional
   * <source> pointing to the original src AFTER the cached source so browser
   * will automatically proceed to the next source if one fails.
   * Original sources are added only when page becomes visible and not during
   * prerender mode.
   *
   * 2) Prerendering
   * Now that some sources might be cached, we can preload them during prerender
   * phase. Runtime handles this by adding any cached sources to the <video>
   * element during prerender and automatically sets the `preload` to `auto`
   * so browsers (based on their own heuristics) can start fetching the cached
   * videos. If `preload` is specified by the author, then it takes precedence.
   *
   * Note that this flag does not impact prerendering of the `poster` as poster
   * is fetched (and is always cached) during `buildCallback` which is not
   * dependent on the value of `prerenderAllowed()`.
   *
   * @override
   * @nocollapse
   */
  static prerenderAllowed(element) {
    // Allow prerender of any video, but update props in the
    // `updatePropsForRendering`.
    return true;
  }

  /** @override */
  isLayoutSupported(layout) {
    userAssert(
      isExperimentOn(this.win, 'bento') ||
        isExperimentOn(this.win, 'bento-video'),
      'expected global "bento" or specific "bento-video" experiment to be enabled'
    );
    return super.isLayoutSupported(layout);
  }

  /** @override */
  init() {
    super.init();
    if (this.getAmpDoc().getVisibilityState() == VisibilityState.PRERENDER) {
      this.getAmpDoc().whenFirstVisible().then(() => {
        // Force re-rendering.
        this.mutateProps({});
      });
    }
  }

  /** @override */
  updatePropsForRendering(props) {
    // Ensure that the video follows pre-render rules described in the
    // `prerenderAllowed`.
    const sources = props['sources'] || [];
    if (props['src']) {
      sources.unshift({
        'src': props['src'],
        'type': props['type'],
        'amp-orig-src': this.element.getAttribute('amp-orig-src'),
      });
      delete props['src'];
      delete props['type'];
    }
    if (this.getAmpDoc().getVisibilityState() == VisibilityState.PRERENDER) {
      // Only cached sources are added during prerender, with all the available
      // transcodes generated by the cache.
      // Origin sources will only be added when document becomes visible.
      props['sources'] = sources.filter(source => isCachedByCdn(source, this.element));
    } else {
      // To handle cases where cached source may 404 if not primed yet,
      // duplicate the `origin` Urls for cached sources and insert them after
      // each.
      for (let i = sources.length - 1; i >= 0; i--) {
        const source = sources[i];
        const origSrc = source['amp-orig-src'];
        if (!origSrc) {
          continue;
        }
        sources.splice(i + 1, 0, {
          ...source,
          'src': origSrc,
        });
      }
      props['sources'] = sources;
    }
  }
}

/**
 * @param {!Object} props
 * @param {!Element} videoElement
 * @return {boolean}
 * @visibleForTesting
 */
export function isCachedByCdn(props, videoElement) {
  const src = element['src'];
  const hasOrigSrcAttr = 'amp-orig-src' in props;
  if (!hasOrigSrcAttr) {
    return false;
  }
  const urlService = Services.urlForDoc(videoElement);
  return urlService.isProxyOrigin(src);
}

AMP.extension(TAG, '1.0', (AMP) => {
  AMP.registerElement(TAG, AmpVideo, CSS);
});
